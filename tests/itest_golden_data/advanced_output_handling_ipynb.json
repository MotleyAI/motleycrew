"from typing import List\n\ndef bubble_sort(arr: List[int]) -> None:\n    \"\"\"\n    Sorts a list of integers in ascending order using the bubble sort algorithm.\n    \n    Args:\n        arr (List[int]): The list of integers to be sorted.\n    \"\"\"\n    n = len(arr)\n    while n > 1:\n        new_n = 0\n        for i in range(1, n):\n            if arr[i-1] > arr[i]:\n                arr[i-1], arr[i] = arr[i], arr[i-1]\n                new_n = i\n        if new_n == 0:\n            break\n        n = new_n\n\ndef main() -> None:\n    \"\"\"\n    Test the bubble sort implementation with sample lists.\n    \"\"\"\n    test_cases = [\n        ([64, 34, 25, 12, 22, 11, 90], \"Sorted list\"),\n        ([], \"Sorted empty list\"),\n        ([1], \"Sorted single element list\"),\n        ([1, 2, 3, 4, 5], \"Sorted already sorted list\"),\n        ([3, 1, 2, 3, 1], \"Sorted list with duplicates\"),\n        ([3, -1, 2, -3, 1], \"Sorted list with negative numbers\"),\n        ([5, 5, 5, 5], \"Sorted list with identical elements\")\n    ]\n    \n    for lst, description in test_cases:\n        bubble_sort(lst)\n        print(f\"{description}: {lst}\")\n\nif __name__ == \"__main__\":\n    main()\n\nThe bubble sort implementation sorts a list of integers in ascending order by repeatedly comparing and swapping adjacent elements if they are in the wrong order. An optimization is added to detect the last position where a swap was made, allowing the loop to break early if the list is already sorted. The `main` function tests the implementation with various sample lists, including edge cases, and prints the sorted results."